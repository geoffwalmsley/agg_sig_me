<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-02-06 Mon 20:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Offers</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Geoff Walmsley" />
<meta name="description" content="How chia offers work"
 />
<meta name="keywords" content="Chia, Chialisp, Chialisp Tutorials, Chialisp Examples, Offers" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="./css/tufte.css" />
<style type="text/css">#content{max-width: 800px}</style>
<style type="text/css">.title{text-align: left;}</style>
<style type="text/css">pre.code{background-color: #111; color: #fff} pre > code{width: 100%; margin-left: 0px;}</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<article id="content">
<h1 class="title">Offers</h1>
<p>
This article attempts to provide a detailed explanation of how offers work. We start with the underlying primitives of coins, coin spends, and spend bundles, and then look at the chialisp for the settlement puzzle which makes offers possible.
</p>

<div id="outline-container-org8c4e6ec" class="outline-2">
<h2 id="org8c4e6ec">Coin</h2>
<div class="outline-text-2" id="text-org8c4e6ec">
<p>
A coin consists of three pieces of information:
<label for="1" class="margin-toggle">&#8853;</label><input type="checkbox" id="1" class="margin-toggle"/><span class="marginnote">Anyone can try to spend any coin - the puzzle which controls the coin will determine whether a signature is required. If the puzzle doesn't include a signature condition then anyone who knows the puzzle can spend the coin.</span>
</p>

<ul class="org-ul">
<li><code class="src src-chialisp">parent_coin_id</code> - the parent coin that created it</li>
<li><code class="src src-chialisp">puzzle_hash</code> - the hash of the program that controls the coin</li>
<li><code class="src src-chialisp">amount</code> - the number of mojos the coin controls</li>
</ul>

<p>
To spend a coin, we have to know the puzzle (program) that equates to the puzzle hash. The output of the program is a set of conditions which create new coins, ask for signatures, check timelocks etc.
</p>
</div>
</div>

<div id="outline-container-orgb4c75d5" class="outline-2">
<h2 id="orgb4c75d5">CoinSpend</h2>
<div class="outline-text-2" id="text-orgb4c75d5">
<p>
A coin spend is the set of information needed to spend a coin:
</p>
<ul class="org-ul">
<li><code>coin</code>: The coin that's being spent, <code class="src src-python">[parent_coin_id, puzzle_hash, amount]</code></li>
<li><code>puzzle_reveal</code>: The program which matches the coin's puzzle_hash</li>
<li><code>solution</code>: Another program that is fed into the puzzle_reveal to provide the input data the program needs to execute</li>
</ul>

<p>
<label for="2" class="margin-toggle">&#8853;</label><input type="checkbox" id="2" class="margin-toggle"/><span class="marginnote">Puzzles don't necessarily have to have a solution, but typically we will pass conditions into the solution that tell the puzzle where they are sending some amount to, and to make assertions or create signatures. See the chialisp condition codes for more info</span>
</p>

<p>
When we try to spend a coin, the node looks at the puzzle_reveal and calculates its treehash, then checks that this treehash equals the puzzle hash of the coin we're attempting to spend.
</p>
</div>
</div>

<div id="outline-container-org102e045" class="outline-2">
<h2 id="org102e045">SpendBundles</h2>
<div class="outline-text-2" id="text-org102e045">
<p>
A SpendBundle consists of:
</p>
<ol class="org-ol">
<li>A list of CoinSpends  (ie a coin, its puzzle, and its solution)</li>
<li>A Signature which approves all the coin spends</li>
</ol>

<p>
The SpendBundle object can be written out as a series of bytes - basically just a big string, and when it gets sent to a full node, the mempool manager reads it, checks it is valid, and either submits it into mempool or returns an error code.
</p>

<p>
Anyone can send any spend bundle to the node for checking and inclusion into mempool. If I create a signed spend bundle for some xch in my wallet, and send the byte string of the spend bundle to you, you are able to submit the spend on your full node. The good thing about signatures is, you can't modify the solution without breaking the signature.
</p>
</div>

<div id="outline-container-org5f346ef" class="outline-3">
<h3 id="org5f346ef">Aggregation</h3>
<div class="outline-text-3" id="text-org5f346ef">
<p>
A useful feature of spend bundles is that they can be aggregated. If you have a set of several spend bundles, you can join them together, even if the coin spends have different signatures they can all be joined together.
</p>
</div>
</div>

<div id="outline-container-org7d09a7d" class="outline-3">
<h3 id="org7d09a7d">Methods</h3>
<div class="outline-text-3" id="text-org7d09a7d">
<p>
The spendbundle object provides two methods which define what happens to the coins used in its coin spends: additions and removals. 
</p>
<ul class="org-ul">
<li><code class="src src-python">SpendBundle.additions()</code> tells us what coins are being created</li>
<li><code class="src src-python">SpendBundle.removals()</code> tells use what coins are being destroyed</li>
</ul>
<p>
It calculates these two sets by running the puzzle and solution and looking at the <code class="src src-chialisp"><span style="color: #00d3d0;">CREATE_COIN</span></code> conditions that are produced (additions), and which coins are included in the coinspend object (removals)
</p>
</div>
</div>
</div>

<div id="outline-container-orgc35341f" class="outline-2">
<h2 id="orgc35341f">How Offers Work</h2>
<div class="outline-text-2" id="text-orgc35341f">
<p>
The basic premise of offers is that I send you a signed spend bundle which spends the coins I want to sell. I publish that spend bundle somewhere, so you can copy it. You then create a spendbundle of the coins I want to buy, and aggregate that with the spend bundle I published. When you submit the complete spend bundle to the node, it checks the spend bundles and if they are all correct, then the spend executes and we make a successful trade.
</p>

<p>
When I create my spend bundle I don't know who is going to accept it, so I don't know the address where my coins should go. I also have to be sure that you're sending me the right coins and amount in return. To solve these problems we use an intermediate puzzle called the settlement puzzle, and use announcements to check that each party is receiving the right coins.
</p>


<div id="orgd8cc0fd" class="figure">
<p><img src="images/Offer.png" alt="Offer.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Outline of the Maker and Taker spends with announcements</p>
</div>


<p>
When the maker creates an offer, they are spending some amount of an asset to the settlement puzzle, which creates a new settlement coin. The maker includes an <code class="src src-chialisp"><span style="color: #00d3d0;">ASSERT_PUZZLE_ANNOUNCEMENT</span></code> conditon in their solution, which asserts the payment they want to receive in exchange for the amount they are offering. This means that their spend can only succeed if there is a matching announcement from a settlement puzzle. The settlement puzzle itself calculates this announcements so there is no way for it to be manipulated.
</p>

<p>
To accept the offer, the taker creates a spend of the requested asset to the settlement puzzle, including an appropriate announcement to match the one coming from the maker's settlement puzzle.
</p>
</div>

<div id="outline-container-orgcb8d0b6" class="outline-3">
<h3 id="orgcb8d0b6">Example of an <code>XCH</code> to  <code>SBX</code> offer</h3>
<div class="outline-text-3" id="text-orgcb8d0b6">
<p>
Lets assume the offer maker wants to create an offer where they will <b>pay <code>1 XCH</code></b> in return for <b><code>100 SBX</code></b> (spacebucks CAT). So they will find a regular <code>XCH</code> coin in their wallet which will make up their part of the trade. They'll also get a puzzlehash where they can receive the <code>SBX</code>.
</p>

<p>
The maker then creates a solution for their <code>XCH</code> coin which produces the following conditions:
</p>

<pre class="code"><code><span style="color: #00d3d0;">CREATE_COIN</span> settlement_puzzle_hash 100000000000
<span style="color: #00d3d0;">ASSERT_PUZZLE_ANNOUNCEMENT</span> (<span style="color: #00bcff;">sha256tree</span> SBX_puzzle_hash 100)     
</code></pre>


<p>
So they're creating a coin with the settlement puzhash, and amount of <code>1 XCH</code>, and they're asserting that there will be a spend of a settlement puzzle that sends <code>100 SBX</code> to their provided <code>SBX_puzzle_hash</code>.
</p>

<p>
They can put this spend bundle into an offer file and send it over to the taker.
</p>

<p>
The taker can inspect the spend bundle and look at its additions to see that it will create a settlement coin denominated in <code>XCH</code>. They also know that there's an announcement of <code>100 SBX</code> to the makers <code>SBX_puzzle_hash</code>. So they go ahead and find an <code>SBX</code> coin with amount <code>100</code>. They then create a spend bundle which sends the <code>100 SBX</code> to <code>settlement_puzzle_hash</code>.
</p>

<p>
<label for="3" class="margin-toggle">&#8853;</label><input type="checkbox" id="3" class="margin-toggle"/><span class="marginnote">Because <code>SBX</code> is a cat, the settlement puzzle gets wrapped by the cat outer layer - but we don't have to worry about that for now.</span>
</p>

<p>
The taker then has two spend bundles:  one from the maker which creates the <code>XCH</code> settlement, and their own which creates the <code>SBX</code> settlement.
</p>

<p>
The <code>XCH</code> settlement coin can only be created if the <code>SBX</code> settlement produces a <code class="src src-chialisp"><span style="color: #00d3d0;">CREATE_PUZZLE_ANNOUNCEMENT</span></code> that it's sending <code>100 SBX</code> to the maker. The taker also requires that there is  a <code class="src src-chialisp"><span style="color: #00d3d0;">CREATE_PUZZLE_ANNOUNCEMENT</span></code> from a settlement puzzle that the <code>1 XCH</code> is being spent to the taker's <code>XCH</code> puzzlehash.
</p>

<p>
The taker then creates the spends of the two settlement coins: For the first settlement (of <code>XCH</code>) they submit a notarized payment of <code>100 SBX</code> to the maker's <code>SBX_puzzle_hash</code>. The  second settlement of <code>SBX</code>, they include a notarized payment of <code>1 XCH</code> to their own puzzle hash.
</p>

<p>
With these 4 coin spends (the maker's <code>XCH</code> spend, the <code>XCH</code> settlement, the taker's <code>SBX</code> spend and the <code>SBX</code> settlement) we now have a complete offer. The maker's <code>XCH</code> goes to the <code>XCH</code> settlement which in turn goes to the taker's <code>XCH</code> puzzle hash. The taker's <code>SBX</code> spend goes to the <code>SBX</code> settlement which in turn goes to the maker's <code>SBX</code> puzzle hash. And there are two announcements: one that the maker is receiving <code>100 SBX</code>, and another that the taker is receiving <code>1 XCH</code>.
</p>

<p>
Any attempt by the taker to screw with the amount or the puzzle hash where the sbx are going will cause the announcnments to fail. Similarly, if they try to spend a different asset, then the cat layer of the settlement puzzle will mean there is an incorrect puzzle hash creating the announcement.
</p>
</div>
</div>

<div id="outline-container-org88afb8d" class="outline-3">
<h3 id="org88afb8d">Exploring the Code</h3>
<div class="outline-text-3" id="text-org88afb8d">
<pre class="code"><code>(<span style="color: #b6a0ff;">mod</span> notarized_payments
  <span style="color: #989898;">;; </span><span style="color: #989898;">`notarized_payments` is a list of notarized coin payments</span>
  <span style="color: #989898;">;; </span><span style="color: #989898;">a notarized coin payment is `(nonce . ((puzzle_hash amount ...) (puzzle_hash amount ...) ...))`</span>
  <span style="color: #989898;">;; </span><span style="color: #989898;">Each notarized coin payment creates some `(CREATE_COIN puzzle_hash amount ...)` payments</span>
  <span style="color: #989898;">;; </span><span style="color: #989898;">and a `(CREATE_PUZZLE_ANNOUNCEMENT (sha256tree notarized_coin_payment))` announcement</span>
  <span style="color: #989898;">;; </span><span style="color: #989898;">The idea is the other side of this trade requires observing the announcement from a</span>
  <span style="color: #989898;">;; </span><span style="color: #989898;">`settlement_payments` puzzle hash as a condition of one or more coin spends.</span>

  (<span style="color: #b6a0ff;">include</span> condition_codes.clvm)
  (<span style="color: #b6a0ff;">include</span> utility_macros.clib)

  (<span style="color: #b6a0ff;">defun</span> <span style="color: #00bcff;">sha256tree</span> (TREE)
     (<span style="color: #00bcff;">if</span> (<span style="color: #00bcff;">l</span> TREE)
         (<span style="color: #00bcff;">sha256</span> 2 (<span style="color: #00bcff;">sha256tree</span> (<span style="color: #00bcff;">f</span> TREE)) (<span style="color: #00bcff;">sha256tree</span> (<span style="color: #00bcff;">r</span> TREE)))
         (<span style="color: #00bcff;">sha256</span> 1 TREE)
     )
  )

  (<span style="color: #b6a0ff;">defun</span> create_coins_for_payment (payment_params so_far)
    (<span style="color: #00bcff;">if</span> payment_params
        (assert (&gt; (<span style="color: #00bcff;">f</span> (<span style="color: #00bcff;">r</span> (<span style="color: #00bcff;">f</span> payment_params))) 0)  <span style="color: #989898;">; </span><span style="color: #989898;">assert the amount is positive</span>
          <span style="color: #989898;">; </span><span style="color: #989898;">then</span>
          (<span style="color: #00bcff;">c</span> (<span style="color: #00bcff;">c</span> <span style="color: #00d3d0;">CREATE_COIN</span> (<span style="color: #00bcff;">f</span> payment_params)) (create_coins_for_payment (<span style="color: #00bcff;">r</span> payment_params) so_far))
        )
        so_far
    )
  )

  (<span style="color: #b6a0ff;">defun-inline</span> create_announcement_for_payment (notarized_payment)
      (<span style="color: #00bcff;">list</span> <span style="color: #00d3d0;">CREATE_PUZZLE_ANNOUNCEMENT</span>
            (<span style="color: #00bcff;">sha256tree</span> notarized_payment))
  )

  (<span style="color: #b6a0ff;">defun-inline</span> augment_condition_<span style="color: #00bcff;">list</span> (notarized_payment so_far)
    (<span style="color: #00bcff;">c</span>
      (create_announcement_for_payment notarized_payment)
      (create_coins_for_payment (<span style="color: #00bcff;">r</span> notarized_payment) so_far)
    )
  )

  (<span style="color: #b6a0ff;">defun</span> construct_condition_<span style="color: #00bcff;">list</span> (notarized_payments)
    (<span style="color: #00bcff;">if</span> notarized_payments
        (augment_condition_<span style="color: #00bcff;">list</span> (<span style="color: #00bcff;">f</span> notarized_payments) (construct_condition_<span style="color: #00bcff;">list</span> (<span style="color: #00bcff;">r</span> notarized_payments)))
        ()
    )
  )

  (construct_condition_<span style="color: #00bcff;">list</span> notarized_payments)

)
</code></pre>
<p>
We'll start by looking at the first dozen or so lines of settlement_payments.clsp. The most important thing here is the input to our mod, namely <code>notarized_payments</code>.  From the docstring following this, we can see that a notarized payment is a tuple of a puzzle_hash and an amount. There is also a nonce, which is the hash of the coins going into the spend, but we don't need to worry about that for now.
</p>

<p>
So what is a notarized payment in this context? It's essentially the thing we're expecting the counter party to do - the payment that we want them to make in order to complete their side of the trade. It's notarized in the sense that it gets signed by the counter-party.
</p>

<p>
The rest of this code block just imports some library code and defines a function to creeate a tree-hash which is just a way of creating a hash of a tree (or list) of data.
</p>

<p>
Now we'll jump to the bottom of the file where we see <code class="src src-chialisp">(construct_condition_<span style="color: #00bcff;">list</span> notarized_payments)</code>. This says we should run the construct_condition_list function, using our notarized_payments variable as input.
</p>

<pre class="code"><code>(<span style="color: #b6a0ff;">defun</span> construct_condition_<span style="color: #00bcff;">list</span> (notarized_payments)
  (<span style="color: #00bcff;">if</span> notarized_payments
      (augment_condition_<span style="color: #00bcff;">list</span> (<span style="color: #00bcff;">f</span> notarized_payments) (construct_condition_<span style="color: #00bcff;">list</span> (<span style="color: #00bcff;">r</span> notarized_payments)))
      ()
  )
)

</code></pre>

<p>
This is a recursive function which takes each element of the list of notarized payments, and passes it to another function: <code>augment_condition_list</code>. It then recurs on the remaining elements of <code>notarized_payments</code>.
</p>

<p>
The <code>augment_condition_list</code> function is responsible for creating the conditions that this puzzle outputs:
</p>

<pre class="code"><code>(<span style="color: #b6a0ff;">defun-inline</span> augment_condition_<span style="color: #00bcff;">list</span> (notarized_payment so_far)
  (<span style="color: #00bcff;">c</span>
    (create_announcement_for_payment notarized_payment)
    (create_coins_for_payment (<span style="color: #00bcff;">r</span> notarized_payment) so_far)
  )
)
</code></pre>

<p>
It takes in a single notarized payment, and creates a cons of two other functions: <code class="src src-chialisp">create_announcement_for_payment</code> and <code class="src src-chialisp">create_coins_for_payment</code>
</p>

<p>
These two functions produce the conditions that the settlement puzzle returns:
</p>

<p>
<code class="src src-chialisp">create_announcement_for_puzzle</code> creates a puzzle announcement of the hash of the notarized payment, i.e. the puzzle hash and amount:
</p>

<pre class="code"><code>(<span style="color: #b6a0ff;">defun-inline</span> create_announcement_for_payment (notarized_payment)
   (<span style="color: #00bcff;">list</span> <span style="color: #00d3d0;">CREATE_PUZZLE_ANNOUNCEMENT</span>
         (<span style="color: #00bcff;">sha256tree</span> notarized_payment))
)
</code></pre>

<p>
<code class="src src-chialisp">create_announcement_for_payment</code> produces the <code class="src src-chialisp"><span style="color: #00d3d0;">CREATE_COIN</span></code> condition using the puzzle hash and amount from the notarized payment.
</p>

<pre class="code"><code>(<span style="color: #b6a0ff;">defun</span> create_coins_for_payment (payment_params so_far)
  (<span style="color: #00bcff;">if</span> payment_params
      (assert (&gt; (<span style="color: #00bcff;">f</span> (<span style="color: #00bcff;">r</span> (<span style="color: #00bcff;">f</span> payment_params))) 0)  <span style="color: #989898;">; </span><span style="color: #989898;">assert the amount is positive</span>
        <span style="color: #989898;">; </span><span style="color: #989898;">then</span>
        (<span style="color: #00bcff;">c</span> (<span style="color: #00bcff;">c</span> <span style="color: #00d3d0;">CREATE_COIN</span> (<span style="color: #00bcff;">f</span> payment_params)) (create_coins_for_payment (<span style="color: #00bcff;">r</span> payment_params) so_far))
      )
      so_far
  )
)
</code></pre>
</div>
</div>
</div>
</article>
<div id="postamble" class="status">
<p class="author">Author: Geoff Walmsley</p>
<p class="date">Created: 2023-02-06 Mon 20:00</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
