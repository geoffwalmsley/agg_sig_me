<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-11-03 Wed 20:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Basics of Singletons</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Geoff Walmsley" />
<meta name="description" content="Index of aggsig.me"
 />
<meta name="keywords" content="Chia, Chialisp, Chialisp Tutorials, Chialisp Examples" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="./css/tufte.css" />
<style type="text/css">#content{max-width: 800px}</style>
<style type="text/css">.title{text-align: left;}</style>
<style type="text/css">pre.code{background-color: #111; color: #fff} pre > code{width: 100%; margin-left: 0px;}</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<article id="content">
<h1 class="title">Basics of Singletons</h1>




<div id="outline-container-org71f8ba9" class="outline-2">
<h2 id="org71f8ba9">Overview</h2>
<div class="outline-text-2" id="text-org71f8ba9">
<p>
The singleton lifecycle starts with a regular old coin from our wallet, \(C\).
</p>

<ol class="org-ol">
<li>Spend some amount of \(C\), to a launcher coin \(C_L\).</li>
<li>Then we spend the launcher coin with a solution that causes the creation of a singleton.</li>
<li>The singleton then does it's EVE spend (first tx after creation)</li>
<li>The EVE spend curries in relevant information to ensure that it is locked to it's parent coin, and parent parent coin.</li>
<li>Future spends of the singleton will require a lineage proof which is defined by the parent coin ids in the EVE spend.</li>
<li>Depending on the inner puzzle of the singleton we can do whatever we want - spend, destroy/melt, make annnouncements etc.</li>
</ol>


<p>
The code components of this process are:
</p>

<ul class="org-ul">
<li>A launcher puzzle</li>
<li>A top-layer-singleton (singleton wrapper for whatever innerpuzzle)</li>
<li>Inner puzzle to go into the singleton</li>
<li>Wallet functions to launch, create, eve-spend, and spend the singleton</li>
<li>Wallet functions to track our singletons</li>
</ul>

<hr />
</div>
</div>

<div id="outline-container-org94fc187" class="outline-2">
<h2 id="org94fc187">The Singleton Launcher</h2>
<div class="outline-text-2" id="text-org94fc187">
</div>
<div id="outline-container-org612a4a8" class="outline-3">
<h3 id="org612a4a8">Curried Inputs</h3>
<div class="outline-text-3" id="text-org612a4a8">
<dl class="org-dl">
<dt><code>None</code></dt><dd></dd>
</dl>
</div>
</div>

<div id="outline-container-orga3b67e8" class="outline-3">
<h3 id="orga3b67e8">Solution Inputs</h3>
<div class="outline-text-3" id="text-orga3b67e8">
<dl class="org-dl">
<dt><code>singleton_full_puzzle_hash</code></dt><dd>The fully curried puzzlehash of the singleton (top-layer with inner puzzle curried in)</dd>
<dt><code>amount</code></dt><dd>The amount that we are taking from our regular coin \(C\)</dd>
<dt><code>key_value_list</code></dt><dd>Any additional data that we want our singleton to carry. This would be where you put the hash of some crappy pixel art.</dd>
</dl>
</div>
</div>

<div id="outline-container-orge20ebd3" class="outline-3">
<h3 id="orge20ebd3">Outputs</h3>
<div class="outline-text-3" id="text-orge20ebd3">
<dl class="org-dl">
<dt><code>CREATE_COIN</code></dt><dd><code>singleton_full_puzzle_hash amount</code></dd>
<dt><code>CREATE_COIN_ANNOUNCEMENT</code></dt><dd><code>(sha256tree1 (list singleton_full_puzzle_hash amount key_value_list))</code></dd>
</dl>
</div>
</div>

<div id="outline-container-org5ba0534" class="outline-3">
<h3 id="org5ba0534">How it works</h3>
<div class="outline-text-3" id="text-org5ba0534">
<ul class="org-ul">
<li>Nothing is curried in to create this puzzle</li>
<li>Once it is launched, when we spend it, it sends the amount to the puzzle hash of our fully curried top-layer puzzle</li>
<li>It also makes an annnouncement of all the input data.</li>
<li>This announcement is asserted by the delegated spend of our regular coin. This is because we do not want a signature in the puzzlehash otherwise we could create multiple of the same NFT using different sigs from the same wallet.</li>
<li>We also want all our singletons to come from a 'generic' puzzlehash so we can use it as proof that it is a singleton</li>
</ul>

<hr />
</div>
</div>
</div>

<div id="outline-container-org9bae1c6" class="outline-2">
<h2 id="org9bae1c6">The Singleton Top Layer</h2>
<div class="outline-text-2" id="text-org9bae1c6">
</div>
<div id="outline-container-orgb7ec740" class="outline-3">
<h3 id="orgb7ec740">Curried Inputs</h3>
<div class="outline-text-3" id="text-orgb7ec740">
<dl class="org-dl">
<dt><code>SINGLETON_STRUCT</code></dt><dd><code>(MOD_HASH . (LAUNCHER_ID . LAUNCHER_PUZZLE_HASH))</code></dd>
<dt><code>INNER_PUZZLE</code></dt><dd>Can be any inner puzzle, not necessarily related to singleton behaviour</dd>
</dl>
</div>
</div>

<div id="outline-container-orga7d7390" class="outline-3">
<h3 id="orga7d7390">Solution Inputs</h3>
<div class="outline-text-3" id="text-orga7d7390">
<dl class="org-dl">
<dt><code>lineage_proof</code></dt><dd><p>
This takes one of two formats:
</p>

<ul class="org-ul">
<li><code>(parent_parent_coin_info parent_inner_puzzle_hash parent_amount)</code> \(\rightarrow\) non-EVE</li>
<li><code>(parent_parent_coin_info parent_amount)</code> \(\rightarrow\) EVE</li>
</ul>

<p>
We use the separate formats because we use the length of the structure to tip us off to whether or not this is the eve spend. The eve spend is the first spend of a singleton after its creation. We use this lineage proof to verify that our parent was a singleton. However, in the first spend, the parent is not a singleton and we actually execute a different path where we verify that our parent was a singleton launcher instead.
</p></dd>
<dt><code>my_amount</code></dt><dd>is the amount of the coin being spent and will be asserted implicitly through <code>ASSERT_MY_COIN_ID</code>.</dd>
<dt><code>inner_solution</code></dt><dd>solution to <code>INNER_PUZZLE</code></dd>
</dl>
</div>
</div>

<div id="outline-container-org9953d9d" class="outline-3">
<h3 id="org9953d9d">Outputs</h3>
<div class="outline-text-3" id="text-org9953d9d">
<dl class="org-dl">
<dt><code>ASSERT_MY_COIN_ID</code></dt><dd>This is handled within singleton top layer.</dd>
<dt><code>INNER_PUZZLE CONDITIONS</code></dt><dd>Whatever conditions get returned by solving the inner puzzle</dd>
</dl>
</div>
</div>

<div id="outline-container-org21832ed" class="outline-3">
<h3 id="org21832ed">How it works</h3>
<div class="outline-text-3" id="text-org21832ed">
<p>
First check whether we are using the eve spend path. If the lineage_proof has 2 elements we are doing the eve spend, in which case we calculate the launcher ID from information in our lineage proof and the launcher puzzle hash. We then assert that it is equal to the curried in value.
This means every subsequent singleton can trust its parent.
</p>

<hr />
</div>
</div>
</div>

<div id="outline-container-orgea169ec" class="outline-2">
<h2 id="orgea169ec">A singleton with p2_delegated_or_hidden as its inner puzzle</h2>
<div class="outline-text-2" id="text-orgea169ec">
<pre class="code"><code>  <span style="color: #00d3d0;">SINGLETON_MOD</span> = load_clsp_relative(<span style="color: #79a8ff;">"clsp/singleton_top_layer.clsp"</span>)
  <span style="color: #00d3d0;">SINGLETON_MOD_HASH</span> = SINGLETON_MOD.get_tree_hash()
  <span style="color: #00d3d0;">P2_SINGLETON_MOD</span> = load_clsp_relative(<span style="color: #79a8ff;">"clsp/p2_singleton.clsp"</span>)
  <span style="color: #00d3d0;">P2_SINGLETON_OR_DELAYED_MOD</span> = load_clsp_relative(<span style="color: #79a8ff;">"clsp/p2_singleton_or_delayed_puzhash.clsp"</span>)
  <span style="color: #00d3d0;">SINGLETON_LAUNCHER</span> = load_clsp_relative(<span style="color: #79a8ff;">"clsp/singleton_launcher.clsp"</span>)
  <span style="color: #00d3d0;">SINGLETON_LAUNCHER_HASH</span> = SINGLETON_LAUNCHER.get_tree_hash()
  <span style="color: #00d3d0;">ESCAPE_VALUE</span> = -113
  <span style="color: #00d3d0;">MELT_CONDITION</span> = [ConditionOpcode.CREATE_COIN, 0, ESCAPE_VALUE]




  <span style="color: #b6a0ff;">async def</span> <span style="color: #feacd0;">create_launcher_spend</span>(spender, singleton_inner_puzzle, amount, key_value_list):
      <span style="color: #79a8ff;">"""This function returns a CoinSpend object for the launcher puzzle.</span>
<span style="color: #79a8ff;">       0. Grab ann input coin and create the launcher_coin coin.</span>
<span style="color: #79a8ff;">       1. Calculate the launcher coin's puzzle solution: singleton_full_puzzle_hash, amount,</span>
<span style="color: #79a8ff;">          and key_value_list</span>
<span style="color: #79a8ff;">       2. Create the expected output conditions (CREATE, ANOUNCE) for launcher</span>
<span style="color: #79a8ff;">       3. Create the matching conditions for the delegated spend of the input coinn</span>
<span style="color: #79a8ff;">       4. Construct coin spend objects for the input coin and launcher coin</span>
<span style="color: #79a8ff;">       5. Work out the necessary message for the found_coin spend</span>
<span style="color: #79a8ff;">       6. Sign coin spends</span>
<span style="color: #79a8ff;">       7. Push the spend to network"""</span>

      <span style="color: #a8a8a8;"># 0. Grab a coin and create launcher coin</span>
      <span style="color: #00d3d0;">found_coin</span> = <span style="color: #b6a0ff;">await</span> spender.choose_coin(amount)
      <span style="color: #00d3d0;">launcher_coin</span> = Coin(found_coin.name(), SINGLETON_LAUNCHER_HASH, amount)

      <span style="color: #a8a8a8;"># 1. Calculate launcher coin's solution</span>
      <span style="color: #a8a8a8;"># To do this we first need the fully curried top layer singleton puzzle.</span>
      <span style="color: #a8a8a8;"># The other two values, amounnt and key_value_list are provided in args</span>
      <span style="color: #00d3d0;">singleton_full_puzzle</span> = SINGLETON_MOD.curry(
                                    (
                                     SINGLETON_MOD_HASH,
                                     (launcher_coin.name(),
                                      SINGLETON_LAUNCHER_HASH)
                                    ),
                                    singleton_inner_puzzle)

      <span style="color: #00d3d0;">singleton_full_puzzle_hash</span> = singleton_full_puzzle.get_tree_hash()

      <span style="color: #00d3d0;">launcher_solution</span> = Program.to([singleton_full_puzzle_hash, amount, key_value_list])

      <span style="color: #a8a8a8;"># 2. Create the expected output conditions for checking</span>
      <span style="color: #a8a8a8;">#    Note that the launcher_solution doubles as the message that is hashed into the</span>
      <span style="color: #a8a8a8;">#    the announcement.</span>

      <span style="color: #00d3d0;">launcher_announcement</span> = Announcement(launcher_coin.name(),
                                           launcher_solution.get_tree_hash())

      <span style="color: #00d3d0;">k</span> = SINGLETON_LAUNCHER.run(launcher_solution)
      <span style="color: #b6a0ff;">print</span>(launcher_solution.get_tree_hash())
      <span style="color: #b6a0ff;">print</span>(k.as_python()[1][1].hex())


      <span style="color: #a8a8a8;"># launcher_announcement.name() should equal treehash of the list of</span>
      <span style="color: #a8a8a8;"># (singleton_full_puzzle_hash, amount, ley_value_list)</span>
      <span style="color: #00d3d0;">output_conditions</span> = [
                           [ConditionOpcode.CREATE_COIN, SINGLETON_LAUNCHER_HASH, amount],
                           [ConditionOpcode.CREATE_COIN_ANNOUNCEMENT, launcher_announcement.name()]
                          ]


      <span style="color: #a8a8a8;"># 3. Create the matching conditions and solution for the input coins delegated spend</span>
      <span style="color: #a8a8a8;">#    ASSERT_COIN_ANNOUNCEMENT - [61] - (61 announcementID)</span>
      <span style="color: #a8a8a8;">#                             - announcementID == sha256(coinID + message).</span>
      <span style="color: #a8a8a8;">#</span>
      <span style="color: #a8a8a8;">#    We can write the announcementID as launcher_annnouncement.name(), or calculate it</span>
      <span style="color: #00d3d0;">input_conditions</span> = [
                  [ConditionOpcode.ASSERT_COIN_ANNOUNCEMENT, std_hash(launcher_coin.name() + launcher_announcement.message)],
                  [ConditionOpcode.CREATE_COIN, launcher_coin.puzzle_hash, amount],

                  [ConditionOpcode.CREATE_COIN, spender.puzzle_hash, found_coin.amount - amount]]


      <span style="color: #00d3d0;">assert_launcher_announcement</span> = Program.to(
          [
              ConditionOpcode.ASSERT_COIN_ANNOUNCEMENT,
              std_hash(launcher_coin.name() + launcher_solution.get_tree_hash()),
           ])

      <span style="color: #b6a0ff;">print</span>(assert_launcher_announcement.as_python())

      <span style="color: #00d3d0;">delegated_puzzle_solution</span> = Program.to((1, input_conditions))
      <span style="color: #00d3d0;">solution</span> = Program.to([[], delegated_puzzle_solution, []])


      <span style="color: #a8a8a8;"># 4. Create the CoinSpends for input and launcher</span>
      <span style="color: #00d3d0;">input_coin_spend</span> = CoinSpend(found_coin.as_coin(),
                             spender.puzzle,
                             solution)


      <span style="color: #00d3d0;">coin_spend</span> = CoinSpend(launcher_coin, SINGLETON_LAUNCHER, launcher_solution)

      <span style="color: #00d3d0;">lineage_proof</span> = singleton_top_layer.lineage_proof_for_coinsol(coin_spend)

      <span style="color: #a8a8a8;"># adding lineage proof here, may use later.</span>
      <span style="color: #a8a8a8;"># lineage_proof = Program.to([launcher_coin.name(), amount])</span>



      <span style="color: #a8a8a8;"># 5. Determine the synthetic keys and message for signing the input coin </span>
      <span style="color: #00d3d0;">cost</span>, <span style="color: #00d3d0;">r</span> = spender.puzzle.run_with_cost(10000000, solution)
      <span style="color: #00d3d0;">ssk</span> = calculate_synthetic_secret_key(spender.sk_, DEFAULT_HIDDEN_PUZZLE_HASH)
      <span style="color: #00d3d0;">spk</span> = ssk.get_g1()

      <span style="color: #00d3d0;">msg</span> = delegated_puzzle_solution.get_tree_hash()\
            + coin_spend.coin.name()\
            + DEFAULT_CONSTANTS.AGG_SIG_ME_ADDITIONAL_DATA

      <span style="color: #a8a8a8;"># 6. Sign the coins and get the spend bundle</span>
      <span style="color: #00d3d0;">sb</span> = <span style="color: #b6a0ff;">await</span> sign_coin_spends([input_coin_spend, coin_spend],
                                   spender.pk_to_sk,
                                   DEFAULT_CONSTANTS.AGG_SIG_ME_ADDITIONAL_DATA,
                                   DEFAULT_CONSTANTS.MAX_BLOCK_COST_CLVM)

      <span style="color: #a8a8a8;"># Print out some relevant info</span>
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"\n\nLauncher CoinID: {launcher_coin.name()}"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"Amount: </span><span style="color: #00d3d0;">{launcher_coin.amount}</span><span style="color: #79a8ff;">"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"\nSpender puzzlehash: {spender.puzzle_hash}"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"Launcher puzzlehash: </span><span style="color: #00d3d0;">{launcher_coin.puzzle_hash}</span><span style="color: #79a8ff;">"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"Singleton Puzzlehash: {singleton_full_puzzle_hash}\n\n"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"\n\nLauncher Announcement:"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"Name:\t {launcher_announcement.name()}"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"Message: </span><span style="color: #00d3d0;">{launcher_announcement.message}</span><span style="color: #79a8ff;">"</span>)
      <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"\n"</span>)
      <span style="color: #b6a0ff;">return</span> lineage_proof, singleton_full_puzzle, launcher_coin, sb
      <span style="color: #a8a8a8;"># return input_coin_spend, coin_spend</span>


  <span style="color: #00d3d0;">network</span>, <span style="color: #00d3d0;">oracle</span>, <span style="color: #00d3d0;">alice</span>, <span style="color: #00d3d0;">bob</span> = asyncio.run(create_sim())
  <span style="color: #00d3d0;">amount</span> = 101

  <span style="color: #a8a8a8;"># We are just going to use alice's inner puzzle as the NFT inner puzzle.</span>
  <span style="color: #a8a8a8;"># For a real NFT we will need to make an innner puzzle that can modify it's pubkey.</span>
  <span style="color: #00d3d0;">adapted_inner_puzzle</span> = singleton_top_layer.adapt_inner_to_singleton(alice.puzzle)


  <span style="color: #a8a8a8;">#adapted_inner_puzzle = INNER_PUZZLE</span>

  <span style="color: #00d3d0;">lineage_proof</span>, <span style="color: #00d3d0;">singleton_full_puzzle</span>, <span style="color: #00d3d0;">launcher_coin</span>, <span style="color: #00d3d0;">sb</span> = asyncio.run(
              create_launcher_spend(
                  alice,
                  <span style="color: #a8a8a8;"># INNER_PUZZLE,</span>
                  adapted_inner_puzzle,
                  amount,
                  (<span style="color: #79a8ff;">"hello"</span>, <span style="color: #79a8ff;">"World"</span>)))

  <span style="color: #00d3d0;">res</span> = asyncio.run(network.push_tx(sb))
  <span style="color: #b6a0ff;">print</span>(<span style="color: #79a8ff;">"EVE COIN"</span>)
  <span style="color: #b6a0ff;">for</span> c <span style="color: #b6a0ff;">in</span> res[<span style="color: #79a8ff;">'additions'</span>]:
      <span style="color: #b6a0ff;">if</span> <span style="color: #00d3d0;">c.puzzle_hash</span> == singleton_full_puzzle.get_tree_hash():
          <span style="color: #00d3d0;">eve_coin</span> = c
          <span style="color: #b6a0ff;">print</span>(c)


  <span style="color: #a8a8a8;"># now we have to make the eve spend. For this we need:</span>
  <span style="color: #a8a8a8;"># - a lineage proof</span>
  <span style="color: #a8a8a8;"># - the nft amount</span>
  <span style="color: #a8a8a8;"># - an inner solution for alices puzzle (i.e. a delegated puzzle)</span>

  <span style="color: #a8a8a8;"># The delegated puzzle we want for alices solution should just recreate the nft coin</span>
  <span style="color: #00d3d0;">recreate_condition</span> = [[ConditionOpcode.CREATE_COIN,
                       adapted_inner_puzzle.get_tree_hash(),
                       eve_coin.amount]]

  <span style="color: #00d3d0;">delegated_puzzle</span> = Program.to((1, recreate_condition))


  <span style="color: #00d3d0;">inner_solution</span>: <span style="color: #00d3d0;">Program</span> = Program.to([[], delegated_puzzle, []])

  <span style="color: #00d3d0;">puzzle_reveal</span>: <span style="color: #00d3d0;">Program</span> = singleton_top_layer.puzzle_for_singleton(
                launcher_coin.name(),
                adapted_inner_puzzle,
            )

  <span style="color: #00d3d0;">full_solution</span>: <span style="color: #00d3d0;">Program</span> = singleton_top_layer.solution_for_singleton(
                lineage_proof,
                eve_coin.amount,
                inner_solution,
            )

  <span style="color: #00d3d0;">eve_spend</span> = CoinSpend(eve_coin, puzzle_reveal, full_solution)

  <span style="color: #00d3d0;">eve_sb</span> = asyncio.run(sign_coin_spends([eve_spend],
                            alice.pk_to_sk,
                            DEFAULT_CONSTANTS.AGG_SIG_ME_ADDITIONAL_DATA,
                            DEFAULT_CONSTANTS.MAX_BLOCK_COST_CLVM))

  <span style="color: #00d3d0;">eve_res</span> = asyncio.run(network.push_tx(eve_sb))

  <span style="color: #00d3d0;">nft_coin</span> = eve_res[<span style="color: #79a8ff;">'additions'</span>][0]
  <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"\nNFT COIN\n{nft_coin}"</span>)

  <span style="color: #a8a8a8;"># now we can spend the nft with the non-eve lineage_proof. The puzzle reveal always uses the launcher coin id.</span>
  <span style="color: #00d3d0;">nft_lineage_proof</span> = singleton_top_layer.lineage_proof_for_coinsol(eve_spend)
  <span style="color: #00d3d0;">nft_puzzle_reveal</span> = singleton_top_layer.puzzle_for_singleton(launcher_coin.name(),
                                                               adapted_inner_puzzle)
  <span style="color: #00d3d0;">nft_solution</span> = singleton_top_layer.solution_for_singleton(
                   nft_lineage_proof,
                   nft_coin.amount,
                   inner_solution)

  <span style="color: #00d3d0;">nft_spend</span> = CoinSpend(nft_coin, nft_puzzle_reveal, nft_solution)
  <span style="color: #00d3d0;">nft_sb</span> = asyncio.run(sign_coin_spends([nft_spend],
                                        alice.pk_to_sk,
                                        DEFAULT_CONSTANTS.AGG_SIG_ME_ADDITIONAL_DATA,
                                        DEFAULT_CONSTANTS.MAX_BLOCK_COST_CLVM))

  <span style="color: #00d3d0;">nft_res</span> = asyncio.run(network.push_tx(nft_sb))
  <span style="color: #00d3d0;">nft_coin_2</span> = nft_res[<span style="color: #79a8ff;">'additions'</span>][0]
  <span style="color: #b6a0ff;">print</span>(f<span style="color: #79a8ff;">"\nNFT COIN\n{nft_coin_2}"</span>)





</code></pre>


<pre class="example" id="org82af715">
2bcdfff7a5a5e99317b175972fa4e2de2601f23c649813999807960a746b85c2
2bcdfff7a5a5e99317b175972fa4e2de2601f23c649813999807960a746b85c2
[&lt;ConditionOpcode.ASSERT_COIN_ANNOUNCEMENT: b'='&gt;, &lt;bytes32: 241527187d38ed3ec539b09edb74728d513b49095dc0cdab594ef55eb44714a5&gt;]


Launcher CoinID: ad4c3cd5da8a351a2fb651e9c7062cd992528b2443564e0275c137b7536fbf21
Amount: 101

Spender puzzlehash: 5abb5d5568b4a7411dd97b3356cfedfac09b5fb35621a7fa29ab9b59dc905fb6
Launcher puzzlehash: eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9
Singleton Puzzlehash: 612b0b483d92f962edfd62111fd169e55d56df1de55bea9c427db3f5ded08eef




Launcher Announcement:
Name:	 241527187d38ed3ec539b09edb74728d513b49095dc0cdab594ef55eb44714a5
Message: 2bcdfff7a5a5e99317b175972fa4e2de2601f23c649813999807960a746b85c2


EVE COIN
{'amount': 101,
 'parent_coin_info': '0xad4c3cd5da8a351a2fb651e9c7062cd992528b2443564e0275c137b7536fbf21',
 'puzzle_hash': '0x612b0b483d92f962edfd62111fd169e55d56df1de55bea9c427db3f5ded08eef'}

NFT COIN
{'amount': 101,
 'parent_coin_info': '0x163f03ae0befa31014e0864debae67d50d41aa12a5abbf35e90bfd10d271e10d',
 'puzzle_hash': '0x612b0b483d92f962edfd62111fd169e55d56df1de55bea9c427db3f5ded08eef'}

NFT COIN
{'amount': 101,
 'parent_coin_info': '0x6c67987f11e1c60e5bdd3c0a50c696baeb2f6ddf98718f0e7529e1c29e0898f2',
 'puzzle_hash': '0x612b0b483d92f962edfd62111fd169e55d56df1de55bea9c427db3f5ded08eef'}
</pre>
</div>
</div>
</article>
<div id="postamble" class="status">
<p class="author">Author: Geoff Walmsley</p>
<p class="date">Created: 2021-11-03 Wed 20:11</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
